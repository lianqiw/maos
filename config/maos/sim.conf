#FILE sim.conf
#Contains common parameters to all setups. 

#Telescope Aperture Configuration.
aper.d     = [30 3.6] #may contain one for [d] or two numbers for [d din]. d is
		      #outer diameter. din is optimal inner hole diameter.
aper.fnamp    = "TMT_23cm6.bin" #The amplitude map contains a cell array
	              # of 2 elements.  The first element is 5x1 vector,
	              # specifying sampling dx, dy, origin coordinate ox, oy and
	              # height (0).  The second element is a NxN square array.
aper.rotdeg   = 0     #Telescope pupil rotation CCW with respect to instrument. 
aper.pupmask  =       #Instrument pupil mask
#defines simulation parameters.
sim.seeds     = [1]   #random seeds. a list. 0 means random seed
sim.start     = 0     #first time step. usually 0.
sim.end       = 500   #last time step (exclusive)
sim.closeloop = 1     #closed loop simulation
sim.dt        = 1/800 #loop sampling time. (WFS integration time)
sim.dtrat_skip= 0     #drop frame every this steps (sim.dt). 0 no drop.
sim.zadeg     = 0     #zenith angle. moved from atm.zadeg
sim.cachedm   = 1     #Caching DM commands to fine sampled grids that matches
	              #the sampling of the WFS and/or science evaluation
	              #grid. speed up simulation
sim.fov       = 120   #The entire FoV diameter in arcsec. Only used during plotting.
#Servo coefficients. There is two cycle delay.
#A is command. e is error signal. at time step n, the command is updated by
#A(n)=A(n-1)*apdm(0)+A(n-2)*apdm(1)+...+e(n-2)*ep
sim.apdm      = [1 0] #this is the default. [0.5 0.5] is used in laos 
sim.epdm      = 0.5   #error gain of high order loop. -1 to scan from 0.1 to 0.9
sim.aldm      = 0     #Additional latency (sim.dt) of the high order loop. 
	      	      #End to end latency is (powfs.dtrat+1+aldm)*sim.dt
sim.aplo      = [1 0] #this is the default. [0.5 0.5] is used in laos.
sim.eplo      = [0.5] #error gain of ngs mode in split tomography
sim.allo      = 0     #Additional latency (sim.dt) of the lo order loop. 
	      	      #End to end latency is (powfs.dtrat+1+allo)*sim.dt
sim.fuseint   = 1     #use fused integrator. for high and low order loop.
 
#Focus tracking gains.
sim.fcfocus   = -1    #cross-over frequency of the focus LPF. lpfocus=2*pi*fc/fs where fs is AO sampling frequency. -1 means 1/10 of NGS frame rate.
sim.mffocus   = 0     #method for focus tracking. 
	      	      #0: disable focus update. 
		      #1: Focus tracking using closed loop gradients, for each LGS independently. (preferred)
		      #2: Focus tracking using closed loop graidnets, for common LGS focus only.

#Uplink laser pointing servo
sim.apupt     = [1 0] #[0.5 0.5] is used in laos.
sim.epupt     = [0.5]   #uplink integrator gain. 
sim.uptideal  = 0     #ideal correction on uplink (debugging)

#Trombone zoom corrector for LGS
sim.zoomdtrat = 266 #dtrat of the trombone controller (averager)
sim.zoomgain  = 0.5 #gain of the trombone controller
sim.zoomshare = 1

#Other
sim.skysim    = 0     #enable presimulation for sky coverage.
sim.parallel  = 1     #make the big loop parallel.
sim.wspsd     =	      #Telescope wind shake PSD input. Nx2. First column is freq
		      #in Hz, Second column is PSD in rad^2/Hz.
sim.wsseq     = 1     #windshake sequency. different wsseq gives different realizations
sim.ncpa_calib= 1     #calibrate NCPA. Only useful if surf is not empty. 
		      #1: use all DMs. 2: use only ground dm
sim.ncpa_ttr  = 1     #Remove average t/t from NCPA for WFS. Equivalent as repositioning WFS.
sim.ncpa_thetax= []   #Coordinate for NCPA calibration (arcsec). empty means follow evl.
sim.ncpa_thetay= []   #Coordinate for NCPA calibration (arcsec)
sim.ncpa_wt    = []   #Weight for each point.
sim.ncpa_hs    = []   #Height of star

#for GPU
gpu.wfs       = 1     #Use GPU for WFS sensing
gpu.evl       = 1     #Use GPU for Performance evaluation
gpu.tomo      = 1     #Use GPU for tomography
gpu.fit       = 1     #Use GPU for DM fitting
gpu.lsr       = 1     #Use GPU for LSR
gpu.psf       = 1     #Use GPU to accumulate PSF.
gpu.moao      = 1     #Use GPU for MOAO

#if mvmport is nonzero connect to the mvm server at mvmhost:mvmport.
sim.mvmhost   = "localhost" #Where does the MVM server run
sim.mvmport   = 0     #which port does the MVM server run. 0: disable mvm server/client
sim.mvmsize   = 0     #number of gradients to send each time. 0 is all.
sim.mvmngpu   = 0     #>0: limit maximum number of gpus to use.	     
#For special purpose
sim.noatm     = 0     #Disable atmosphere generation (to evaluate telescope errors).
sim.evlol     = 0     #evaluate open loop performance only. don't do wfs/tomo/recon.
sim.psfr      = 0     #Save PSF reconstruction telemetry.
sim.ecnn      = 0     #Estimate WF covariance due to WFS noise cov Cnn.
sim.wfsalias  = 0     #Study the wfs aliasing effect by project turbulence onto
  	      	      #the orthogonal of the DM vector space.
sim.idealfit  = 0     #evaluation ideal fit error only. no wfs, no recon. (was fitonly)
sim.idealtomo = 0     #ideal tomography without wfs (directly propagate from turbulence).
sim.idealwfs  = 0     #Implements ideal WFS by only using turbulence in DM range. conflicts sim.wfsalias
sim.idealevl  = 0     #Evaluate the performance only in DM range.
sim.ahstfocus = 0     #>0: the first plate scale mode creates no focus error on science
	      	      #=1: do not null the focus offset of the first plate scale mode on LGS WFS (preferred)
		      #=2: null the focus effect of the first plate mode on LGS WFS gradients

#Common atmospheric parameters
atm.fractal   = 0     #Use fractal method to generate atmosphere screen. 0: fft method.
atm.size      = [0 0] #size of atmosphere in meter. 0: automatic.
atm.dx        = 1/64  #sampling of the atmosphere, match evl.dx
atm.wdrand    = 1     #>0: as additional seed to randomize wind direction 
atm.evolve    = 0     #evolve the atm in additional to frozen flow. developed
		      #for fractal since it does not wrap. Need twice as storage.
atm.frozenflow=0      #using frozen flow screen (at OL. CL is always frozenflow)
atm.ninit     = 17    #Initial size of the screen in fractal method. >=2
atm.share     = 1     #We share atmosphere by default.

#CN2 Estimation
cn2.pair      = []    #pairs of wfs to estimate cn2. empty to disable cn2 estimation.
cn2.step      = 100   #do cn2 estimation every this time step
cn2.reset     = 0     #reset the accumulated cn2 after every cn2step.
cn2.hmax      = 18000 #maximum height to esimate at zenith
cn2.saat      = 0.95  #subaperture area threashold to use in cn2 estimation
cn2.keepht    = 1     #1: keep the layer ht specified by atmr.ht by
		      #interpolation. 2: do slodar directly on these layers.
cn2.tomo      = 0     #update tomography parameters if non zero
cn2.verbose   = 1     #output estimated r0, cn2 during simulation
cn2.nhtomo    = 6     #number of layers to feed into reconstructor. only effective if keepht==0
cn2.moveht    = 0     #move the ht used for reconstructor to near strongest layers. only
                      #effective if keepht=0.

#set MOAO DMs parameters.
moao.order    = [0]   #override this if moao is required.
moao.cubic    = [1]
moao.iac      = [0.3]
moao.gdm      = [0.5]
moao.stroke   = [inf]
moao.actslave = [0]
moao.lrt_ptt  = [0]
moao.actstuck = [""]
moao.actfloat = [""]
moao.ar       = [1]
#some common fov parameters
evl.dx      = 1/64  #sampling of the aperture in simulation
evl.psf     = [1] #output psf for this direction if psf is computed. 1 or nevl elements.
evl.psfr    = [1] #output psf reconstruction telemetry for this direction.
evl.hs      = [inf] #the height of the science object. normally infinity. 
evl.rmax    = 1   #max radial order in performance evaluation. 
	       #1: includes piston/tip/tilt. 2: p/t/t/focus/astigmatism
evl.tomo    = 0 #evaluate CL error for tomography
evl.moao    = -1 #index into MOAO config in recon.conf
evl.psfhist = 0 #output history of the psf (a lot of storage). 
evl.psfmean = 0 #output time averaged psf. for this number of psf's along the
		#way. 1: only save in the end. n: save cumulative average every
		#n steps (do not reset)
evl.psfol   = 1 #compute OL psf in additional to CL PSF. 0: disable 1: on axis
	        #direction only, 2: all directions and average them.
evl.psfngsr = 0 #remove NGS modes from PSF in split tomography mode. 
	      	# 1: both normal psf and psf with ngsmod removal are saved.
		# 2: only psf with ngs mode removed is computed.
evl.opdcov  = 0 #save covariance of opd for directions where evl.psf==1.

evl.wvl     = [1.25e-6 1.65e-6 2.2e-6]#wavelength to evaluat PSF or strehl
evl.psfpttr = [0] #remove p/t/t in wavefront OPD before computing PSF.
evl.psfisim = 20  #time step to start psfmean/psfhist
evl.psfgridsize = [] #FFT grid size for psf computation for each
		     #wavelength. 0,1,or nwvl number of elements. 0:
		     #automatic. This determines the sampling of the computed
		     #PSF. length matches evl.wvl
evl.psfsize = []    #size of the psf to output. The large PSF is cut to this
		    #size. Set to 1 to compute strehl only. 1 or nwvl number of
		    #elements(for each wvl)

#some common DM parameters that are usually the same for each DM. Can take either 1 or ndm values.
dm.guard  = [1]    #extra DM actuator rings in actuator grid. minimum of 2 for cubic influence function. changed to 1 on Aug 9, 2013
dm.stroke = [inf]  #surface stroke in meter. opd is [-stroke stroke]
dm.iastroke=[inf]  #surface inter-actuator stroke in meter. 
dm.cubic  = [1]    #1: cubic influence function, with dm.iac as inter-actuator-coupling.
dm.iac    = [0.3]  #inter-actuator-coupling coefficient.  
dm.hist   = [0]    #output histogram of DM actuator commands.
dm.histbin= [1e-7] #The bin size for DM histogram computation.
dm.histn  = [201]  #Total number of bins. odd number, centered around zero.
dm.vmisreg= [0]    #vertical misregistration. not implemented yet.
dm.hyst   = [""]   #File containing a matrix that describes the hysterisis. The
		   #matrix should have 3 rows, and multiple columns. Each column
		   #describe the parameters for a mode, and the rows are: 1)
		   #weight 2) alpha, 3) beta. See "Hysteresis Modeling and
		   #Simulation" by Luc Gilles. Notice that this alpha is alpha
		   #in laos multiplied by 0.5e-6.
dm.actfloat = [""] #file containing floating actuators. nx2 coordinate
dm.actstuck = [""] #file containing stuck actuators. nx2 coordinate.
dm.ar     = [1]    #DM aspect ratio. dy/dx spacing

#All misregistrations/distortions are specified here
misreg.tel2wfs=[] #From telescope pupil (atmosphere) to WFS
misreg.dm2wfs=[] #From DM to WFS
misreg.dm2sci=[] #From DM to science.
misreg.pupil=[0 0]  #2 numbers only. Misregistration of pupil wrt to AO and instrument.